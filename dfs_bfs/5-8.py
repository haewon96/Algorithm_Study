# 예제 5-8 : DFS 예제

# DFS 함수 정의
def dfs(graph, v, visited):
    # graph : 그래프 정보 / v: 시작 노드 / visited : 방문 처리 여부 기록 정보

    # 현재 노드를 방문 처리
    visited[v] = True    # 해당 노드 방문 처리
    print(v, end=' ')    # 방문 처리의 의미로 해당 노드 번호 출력

    # 현재 노드와 연결된 다른 노드를 재귀적으로 방문
    for i in graph[v]:   # 현재 확인하고 있는 스택의 최상단 노드와 연결된 다른 노드를 하나씩 확인하면서
        if not visited[i]:   # 인접한 노드가 방문되지 않은 상태라면
            dfs(graph, i, visited)   # 그 노드에 대해서 재귀함수를 이용한 방문 진행
    # 재귀적으로 방문하지 않은 노드들을 계속해서 방문해나감 -> DFS 깊이 우선 탐색

# 각 노드가 연결된 정보를 리스트 자료형으로 표현 (그래프 표현을 위한 2차원 리스트)
graph = [
    [],   # 인덱스 0 비워두기 <- 일반적으로 그래프 문제가 출제되면 노드의 번호가 1번부터 시작되는 경우가 많음
    [2, 3, 8],   # 인덱스 1부터 인덱스 8까지 해당 노드에 인접한 노드를 리스트 형태로 담기 <- 인접리스트 방식 그래프 표현
    [1, 7],
    [1, 4, 5],
    [3, 5],
    [3, 4],
    [7],
    [2, 6, 8],
    [1, 7]
]

# 각 노드가 방문된 정보를 리스트 자료형으로 표현 (방문 처리를 위한 1차원 리스트)
visited = [False] * 9   # 기본적으로 모든 값들을 False로 초기화 (처음에는 아직 하나도 방문 X)
                        # 1번 노드부터 8번 노드까지 (0번 노드 사용 x) -> 하나 더 큰 크기로 초기화 필요

# 정의된 DFS 함수 호출
dfs(graph, 1, visited)



"""
### 인접 행렬 방식 : 2차원 배열에 각 노드가 연결된 형태를 기록하는 방식 -> 2차원 리스트로 구현

INF = 999999999   # 무한의 비용 선언 <- 연결 되어 있지 않은 노드

# 2차원 리스트를 이용해 인접 행렬 표현
graph = [
    [0, 7, 5],
    [7, 0, INF],
    [5, INF, 0]
]

print(graph)
"""
